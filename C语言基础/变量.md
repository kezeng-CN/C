# 变量

## 常量

* 文字常量  
  * 数值常量:如123, 1234L, 033, 0x2f, 123.56e6  
  * 字符常量:'A', 'a', '0', '\t', '\r', '\n'  
  * 字符串常量: "hello world", "cppcourse"  
* 符号常量:\#define 定义的常量  

对于回车换行符的说明:  
\r 回车 carriage return 简称CR指光标定位到行首  
\n 换行 line feed 简称LF指光标移到下一行

通常换行所指:光标定位到行首+光标移到下一行 = `\r` + `\n`  
不同平台回车也不同:  
1. Windows平台: \r\n CRLF  
2. Unix平台: \n LF  
3. Mac: \f CR  

## 变量

### 整型变量特点

1. 未初始化局部整型变量值不可预估
2. 未初始化全局整型变量值为0
3. 未初始化的局部或全局整型变量值为0

```cpp
#include <stdio.h>
int n_global;
static int sn_global;
int main(void)
{
    int n_local; // 定义了整型变量,但不初始化
    printf("未初始化局部整型变量值不可预估:%d \n", n_local);
    printf("未初始化全局整型变量值为0:%d \n", n_global);
    static int sn_local;
    printf("未初始化的局部或全局整型变量值为0,静态全局:%d静态局部:%d \n", sn_global, sn_local); 
    return 0;
}
```

程序运行结果

> $ ./a.out  
> 未初始化局部整型变量值不可预估:96501814  
> 未初始化全局整型变量值为0:0  
> 未初始化的局部或全局整型变量值为0,静态全局:0静态局部:0  
> $ ./a.out  
> 未初始化局部整型变量值不可预估:489664566  
> 未初始化全局整型变量值为0:0  
> 未初始化的局部或全局整型变量值为0,静态全局:0静态局部:0  
> $ ./a.out  
> 未初始化局部整型变量值不可预估:473559094  
> 未初始化全局整型变量值为0:0  
> 未初始化的局部或全局整型变量值为0,静态全局:0静态局部:0

三次运行的结果中未初始化的局部整型变量值均不相同

## elf文件

对于不同变量内存中的分配不一样,对于一个可执行目标文件实际上是elf文件格式  
elf文件包括

* elf文件头信息
* 程序头
* 代码段
* 数据段
* ...

> $ readelf -a a.out

Mac下没有readelf通过brew安装`brew install readelf`  
安装完成后会提示

> binutils is keg-only, which means it was not symlinked into /usr/local,  
> because because Apple provides the same tools and binutils is poorly supported on macOS.
>
> If you need to have binutils first in your PATH run:  
>   echo 'export PATH="/usr/local/opt/binutils/bin:$PATH"' &gt;&gt; ~/.bash\_profile
>
> For compilers to find binutils you may need to set:  
>   export LDFLAGS="-L/usr/local/opt/binutils/lib"  
>   export CPPFLAGS="-I/usr/local/opt/binutils/include"

binutils没有符号链接,并且对macOS支持不好,使用之前需要配置~/.bash\_profile

> $ echo 'export PATH="/usr/local/opt/binutils/bin:$PATH"' &gt;&gt; ~/.bash\_profile  
> $ source ~/.bash\_profile

### elf文件中section和segment

elf是可执行目标文件的一种格式,section和segment是对elf文件中一部分相同内容的不同描述

#### section的作用

源程序转成汇编程序转成可执行目标文件,汇编每一段开头都有不同的声明,表示接下来一段的内容是什么,section本身的作用就是来自于汇编中的声明

#### segment的作用

多个可重定向目标文件要整合成一个可执行目标文件的时候,链接器把目标文件中相同的session整合成一个segment,在程序运行的时候方便加载器的加载

### elf文件解析

[elf文件解析](elf文件解析.md)

### 内存分段

对于内存跟elf分段相似也是分段的,程序可以按照一定的格式保存,并对应加载到不同段中

![虚拟内存映射物理内存地址](/C语言基础/虚拟内存映射物理内存地址.jpg)

内存分段的好处如下

1. 程序指令与数据分区
2. 不同段不同权限控制,代码段只读,数据段可读写,防止代码段中的指令被修改,即图中User text只读,User data可读写
3. 提高程序可靠性,利于缓存
4. 多个进程可以共享存储器中的数据或代码,减少物理内存使用,即图中program data数据可以被多个进程共享

## 可重定向目标文件整合可执行目标文件

c语言代码生成可执行文件可以分为如下几个步骤:  
* 源程序 hello.c(文本)
    * 预处理器cpp 处理
* 被修改的源程序 hello.i(文本)
    * 编译器ccl 编译
* 汇编程序 hello.s(文本)
    * 汇编器as 汇编
* 可重定位目标程序hello.o(二进制)
    * 链接器ld 链接
* 可执行目标程序hello(二进制)

链接器将多个目标文件合并在一起,主要作用是重定位,将目标文件的函数地址/变量地址重新定位

```cpp
#include <stdio.h>
int main()
{
    printf("%s", "hello world!\n");
    return 0;
}
```

通过`gcc -c 1.c`编译上面1.c文件的目标文件1.o

> $ gcc -c 1.c
> $ ls
> 1.c  1.o

通过`objdump -S 1.o`查看1.o的汇编代码



利用`size`命令查看.o文件的总段信息

* \_\_TEXT 107 代码段  
* \_\_DATA 0 数据段目前没有数据

## 变量的作用域

对于局部变量出作用域会随之自动释放  
对于静态局部变量出作用域并不会销毁

