# 基本数据类型

字符,整数,浮点数

## 字符和整数

表格所示

| 类型 | 位 | 取值范围 |
| :--- | :--- | :--- |
| char | 8 | -128～127 |
| unsigned char | 8 | 0～255 |
| short \[int\] | 16 | -32768~32767 |
| unsigned short \[int\] | 16 | 0~65536 |
| int | 32 | -2147483648~2147483647 |
| unsigned \[int\] | 32 | 0~4294967295 |
| long \[int\] | 32 | -2147483648~2147483647 |
| unsigned long \[int\] | 32 | 0~4294967295 |
| long long \[int\] | 64 | -9223372036854775808~9223372036854775807 |
| unsigned long long \[int\] | 64 | 0~18446744073709551615 |

### 类型长度

打印编译器中定义的数据类型长度

```cpp
#include <stdio.h>
int main(void)
{
    printf("%lu\n", sizeof(char));
    printf("%lu\n", sizeof(int));
    printf("%lu\n", sizeof(long));
}
```

输出各个类型结果

> 1  
> 4  
> 8

### 数据存储

如下程序说明数据以补码形式存储

```cpp
#include <stdio.h>
int main(void)
{
    printf("%hhd\n", -1); // 以一个字节有符号十进制数输出-1
    printf("%hhu\n", -1); // 以一个字节无符号十进制数输出-1
    printf("%hhd\n", 128); // 以一个字节有符号十进制数输出128
    printf("%hhu\n", 128); // 以一个字节无符号十进制数输出128
    return 0;
}
```

输出十进制数结果

> -1  
> 255  
> -128  
> 128

-1的值是`[1111 1111]补`在无符号数输出时不会判断符号位而将-1的符号位当成了数据有效位直接输出,因而无符号数的输出是255  
128的值是`[1000 0000]补`在有符号数中将128的数据有效位当成了符号位,因而输出是-128

### 符号位拓展

如下程序说明符号位拓展

```cpp
#include <stdio.h>
int main(void)
{
    char ch = 128;
    printf("%d\n", ch); // 以四个字节有符号十进制数输出128
    printf("%hhd\n", ch); // 以一个字节有符号十进制数输出128
    printf("%hd\n", ch); // 以两个字节有符号十进制数输出128
    printf("%hu\n", ch); // 以两个字节无符号十进制数输出128
    return 0;
}
```

输出结果

> -128  
> -128  
> -128  
> 65408

char类型赋值-128和128都是`[1000 0000]补`即是`[0X80]补`,而负数在符号位前补1正数在符号位前补0都不影响其数值；  
`%d`是四字节`[0X80]补`在符号位前补1`[0XFFFF FF80]补`结果为-128  
`%hhd`是一字节直接输出`[0X80]补`结果为-128  
`%hd`是两字节在符号位前补1`[0XFF80]补`结果为-128  
`%hu`是两个字节,但是由于他是无符号数`[0XFF80]补`将全部看作数字有效位即65408

## 浮点数

浮点数格式标准:IEEE 754

| 类型 | 位 | 取值范围 |
| :--- | :--- | :--- |
| float | 32 | 7位十进制有效数字:-3.40282347E+38~3.40282347E+38 |
| double | 64 | 16位十进制有效数字:-1.7976931348623157E+308~1.7976931348623157E+308 |
| long double | 128 | 19位十进制有效数字:1.18973149535723176502E+4932 |

打印编译器中定义的数据类型长度

```cpp
#include <stdio.h>
int main(void)
{
    printf("%d\n",sizeof(float));
    printf("%d\n",sizeof(double));
    printf("%d\n",sizeof(long double));
    return 0;
}
```

运行结果如下

> 4  
> 8  
> 16

### 数值常量后缀

| 后缀字母 | 用途 | 示例 |
| :--- | :--- | :--- |
| U或者u | 无符号整型 | 123u,2345U |
| L或者l | 长整型 | 123L,-789l |
| F或者f | 单精度浮点型 | 0.123F,3.1415f |

整数:123 075\(0开头是8进制的表示\) 0xA8\(16进制表示\)123U 95538L  
双精度浮点数:123.5 0.8 .003 2.45E17 105.4e-10  
单精度浮点数:1.3F 1.783E-3F  
长双精度浮点数:4.317E34L 3.5L .05L

```cpp
#include <stdio.h>
int main(void)
{
    printf("整数\n");
    printf("123:%d\n075:%d\n0xA8:%d\n123U:%d\n95538L:%ld\n", 123, 075, 0xA8, 123U, 95538L);
    printf("双精度浮点数\n");
    printf("123.5:%lf\n0.8:%lf\n.003:%lf\n2.45E17:%lf\n105.4e-10:%lf\n", 123.5, 0.8, .003, 2.45E17, 105.4e-10);
    printf("单精度浮点数\n");
    printf("1.3F:%f\n1.783E-3F:%f\n", 1.3F, 1.783E-3F);
    printf("长双精度浮点数\n");
    printf("3.417E34L:%Lf\n3.5L:%Lf\n.05L:%Lf\n", 3.417E34L, 3.5L, .05L);
    printf("超过float最大值3.4e39f:%f\n", 3.4e39f);
    printf("超过double最大值1.8e308:%lf\n", 1.8e308);
    printf("通过long double输出1.8e308l:%Lf\n", 1.8e308l);
    return 0;
}
```

运行结果如下

> 整数  
> 123:123  
> 075:61  
> 0xA8:168  
> 123U:123  
> 95538L:95538  
> 双精度浮点数  
> 123.5:123.500000  
> 0.8:0.800000  
> .003:0.003000  
> 2.45E17:245000000000000000.000000  
> 105.4e-10:0.000000  
> 单精度浮点数  
> 1.3F:1.300000  
> 1.783E-3F:0.001783  
> 长双精度浮点数  
> 3.417E34L:34170000000000000001102936864194560.000000  
> 3.5L:3.500000  
> .05L:0.050000  
> 超过float最大值3.4e39f:inf  
> 超过double最大值1.8e308:inf  
> 通过long double输出1.8e308l:179999999999999999999881771787362161637220209158073133960560422505416127280029255244107997673859226438283514044626429957209025499007974251385432967893475410210273172413073335453312363908086675820212949905714122235220658169597814084147124893145992785623648605092105720908059815938226685343159956237414219907072.000000

## 总结

* 作为基础数据类型int效率比其它整型更优
* unsigned不判断符号位使用需要更加谨慎
* 常量后缀f代表单精度,没有后缀代表双精度,后缀l代表长双精度
* long double变量描述符可以用`%llf`也可以用`%Lf`
